//
//  CAtomicsTests.swift
//  AtomicsTests
//
//  Copyright Â© 2016-2020 Guillaume Lessard. All rights reserved.
//  This file is distributed under the BSD 3-clause license. See LICENSE for details.
//

import XCTest

import CAtomicsPrimitives
% integers = ['Int', 'UInt', 'Int8', 'UInt8', 'Int16', 'UInt16', 'Int32', 'UInt32', 'Int64', 'UInt64']

public class CAtomicsBasicTests: XCTestCase
{
% for i in integers:
  public func test${i}()
  {
    let r1 = ${i}(0)
    let r2 = ${i}.randomPositive()
    let r3 = ${i}.randomPositive()

    var i = Atomic${i}(encoding: r1)
    XCTAssertEqual(r1, i.decode())
    XCTAssertEqual(CAtomicsIsLockFree(&i), true)

    CAtomicsStore(&i, Atomic${i}(encoding: r1), .relaxed)
    var j = CAtomicsLoad(&i, .relaxed)
    XCTAssertEqual(i.decode(), j.decode())

    j = CAtomicsExchange(&i, Atomic${i}(encoding: r2), .relaxed)
    XCTAssertEqual(r1, j.decode())
    XCTAssertEqual(r2, i.decode())

    j = CAtomicsAdd(&i, Atomic${i}(encoding: r1), .relaxed)
    XCTAssertEqual(r2, j.decode())
    XCTAssertEqual(r1 &+ r2, i.decode())

    j = CAtomicsSubtract(&i, Atomic${i}(encoding: r2), .relaxed)
    XCTAssertEqual(r1 &+ r2, j.decode())
    XCTAssertEqual(r1, i.decode())

    CAtomicsStore(&i, Atomic${i}(encoding: r1), .relaxed)
    j = CAtomicsBitwiseOr(&i, Atomic${i}(encoding: r2), .relaxed)
    XCTAssertEqual(r1, j.decode())
    XCTAssertEqual(r1 | r2, i.decode())

    CAtomicsStore(&i, Atomic${i}(encoding: r2), .relaxed)
    j = CAtomicsBitwiseXor(&i, Atomic${i}(encoding: r1), .relaxed)
    XCTAssertEqual(r2, j.decode())
    XCTAssertEqual(r1 ^ r2, i.decode())

    CAtomicsStore(&i, Atomic${i}(encoding: r1), .relaxed)
    j = CAtomicsBitwiseAnd(&i, Atomic${i}(encoding: r2), .relaxed)
    XCTAssertEqual(r1, j.decode())
    XCTAssertEqual(r1 & r2, i.decode())

    j = Atomic${i}(encoding: r1)
    CAtomicsStore(&i, Atomic${i}(encoding: r1), .relaxed)
    XCTAssertTrue(CAtomicsCompareAndExchangeStrong(&i, &j, Atomic${i}(encoding: r2), .relaxed, .relaxed))
    XCTAssertEqual(r2, i.decode())

    j = Atomic${i}(encoding: r2)
    CAtomicsStore(&i, Atomic${i}(encoding: r1), .relaxed)
    while(!CAtomicsCompareAndExchangeWeak(&i, &j, Atomic${i}(encoding: r3), .relaxed, .relaxed)) {}
    XCTAssertEqual(r1, j.decode())
    XCTAssertEqual(r3, i.decode())

  }

% end
% pointers = ['AtomicRawPointer', 'AtomicMutableRawPointer']
% for type in pointers:
  public func test${type}()
  {
% mutable = 'Mutable' if 'Mutable' in type else ''
% prefix = 'Unsafe' + mutable + 'Raw'
    let r0 = ${prefix}Pointer(bitPattern: 0)
    let r1 = ${prefix}Pointer(bitPattern: UInt.randomPositive())
    let r2 = ${prefix}Pointer(bitPattern: UInt.randomPositive())
    let r3 = ${prefix}Pointer(bitPattern: UInt.randomPositive())

    var i = ${type}(encoding: r0)
    XCTAssertEqual(r0, i.decode())
    XCTAssertEqual(CAtomicsIsLockFree(&i), true)

    CAtomicsStore(&i, ${type}(encoding: r1), .relaxed)
    var j = CAtomicsLoad(&i, .relaxed)
    XCTAssertEqual(i.decode(), j.decode())

    j = CAtomicsExchange(&i, ${type}(encoding: r2), .relaxed)
    XCTAssertEqual(r1, j.decode())
    XCTAssertEqual(r2, i.decode())

    XCTAssertEqual(CAtomicsCompareAndExchangeStrong(&i, &j, ${type}(encoding: r2), .relaxed, .relaxed), false)
    XCTAssertEqual(r2, j.decode())

    XCTAssertEqual(CAtomicsCompareAndExchangeStrong(&i, &j, ${type}(encoding: r3), .relaxed, .relaxed), true)
    XCTAssertEqual(r2, j.decode())

    while !CAtomicsCompareAndExchangeWeak(&i, &j, ${type}(encoding: r1), .relaxed, .relaxed) {}
    XCTAssertEqual(r3, j.decode())
    XCTAssertEqual(r1, i.decode())
  }

% end
  public func testFence()
  {
    CAtomicsThreadFence(.release)
    CAtomicsThreadFence(.acquire)
  }
}

% taggedPointers = ['TaggedRawPointer', 'TaggedMutableRawPointer']
% for taggedPointer in taggedPointers:
extension ${taggedPointer}: Equatable
{
  static public func ==(lhs: ${taggedPointer}, rhs: ${taggedPointer}) -> Bool
  {
    return (lhs.ptr == rhs.ptr) && (lhs.tag == rhs.tag)
  }
}

% end # for
extension CAtomicsBasicTests
{
% taggedPointers = ['TaggedRawPointer', 'TaggedMutableRawPointer']
% for taggedPointer in taggedPointers:
% mutable = 'Mutable' if 'Mutable' in type else ''
  public func test${taggedPointer}()
  {
    let r0 = ${taggedPointer}(Unsafe${mutable}RawPointer(bitPattern: UInt.randomPositive()), tag: .randomPositive())
    var r1 = ${taggedPointer}(nil, tag: 0)

    XCTAssertNotEqual(r0, r1)

    r1 = r0
    XCTAssertEqual(r0, r1)

    r1.tag += 1
    XCTAssertNotEqual(r0, r1)
    XCTAssertEqual(r0.ptr, r1.ptr)
    XCTAssertEqual(r0.tag &+ 1, r1.tag)

    r1.ptr = nil
    XCTAssertEqual(nil, r1.ptr)
    XCTAssertNotEqual(r0.ptr, r1.ptr)
    XCTAssertEqual(r0.tag &+ 1, r1.tag)
  }

  public func testAtomic${taggedPointer}()
  {
    let r0 = ${taggedPointer}(nil, tag: 0)
    let r1 = ${taggedPointer}(Unsafe${mutable}RawPointer(bitPattern: UInt.randomPositive()), tag: 1)
    let r2 = ${taggedPointer}(Unsafe${mutable}RawPointer(bitPattern: UInt.randomPositive()), tag: 2)
    let r3 = ${taggedPointer}(Unsafe${mutable}RawPointer(bitPattern: UInt.randomPositive()), tag: 3)

    var i = Atomic${taggedPointer}(r0)
    XCTAssertEqual(r0, i.decode())
    XCTAssertEqual(CAtomicsIsLockFree(&i), true)

    CAtomicsStore(&i, Atomic${taggedPointer}(r1), .relaxed)
    var j = CAtomicsLoad(&i, .relaxed)
    XCTAssertEqual(i.decode(), j.decode())

    j = CAtomicsExchange(&i, Atomic${taggedPointer}(r2), .relaxed)
    XCTAssertEqual(r1, j.decode())
    XCTAssertEqual(r2, i.decode())

    XCTAssertEqual(CAtomicsCompareAndExchangeStrong(&i, &j, Atomic${taggedPointer}(r2), .relaxed, .relaxed), false)
    XCTAssertEqual(r2, j.decode())

    XCTAssertEqual(CAtomicsCompareAndExchangeStrong(&i, &j, Atomic${taggedPointer}(r3), .relaxed, .relaxed), true)
    XCTAssertEqual(r2, j.decode())

    while !CAtomicsCompareAndExchangeWeak(&i, &j, Atomic${taggedPointer}(r1), .relaxed, .relaxed) {}
    XCTAssertEqual(r3, j.decode())
    XCTAssertEqual(r1, i.decode())
  }

% end # for
}
