//
//  AtomicIntegers.swift
//
//  Licensed under Apache License v2.0
//

import CAtomicsPrimitives
% for Type in ['Int', 'UInt', 'Int8', 'UInt8', 'Int16', 'UInt16', 'Int32', 'UInt32', 'Int64', 'UInt64']:

extension ${Type}: AtomicProtocol
{
  public typealias AtomicStorage = Atomic${Type}

#if swift(>=4.2)
% for inlinable in ['@inlinable', '@inline(__always)']:
% end = '#else' if inlinable == '@inlinable' else '#endif'
  ${inlinable}
  public static func prepareAtomicStorage(for value: ${Type}) -> Atomic${Type}
  {
    return encodeAtomicStorage(for: value)
  }

  ${inlinable}
  public static func disposeAtomicStorage(_ storage: inout Atomic${Type}) -> ${Type}
  {
    return decodeAtomicStorage(storage)
  }

  ${inlinable}
  public static func encodeAtomicStorage(for value: ${Type}) -> Atomic${Type}
  {
    return Atomic${Type}(value)
  }

  ${inlinable}
  public static func decodeAtomicStorage(_ storage: Atomic${Type}) -> ${Type}
  {
    return storage.decode()
  }
${end}
% end # inlinable
}

%{
  rmwOperations = [
    ('WrappingDecrement', 'Subtract',  'by'),
    ('BitwiseAnd',        'BitwiseAnd', 'with'),
    ('BitwiseOr',         'BitwiseOr',  'with'),
    ('BitwiseXor',        'BitwiseXor', 'with'),
  ]
}%

extension ${Type}: AtomicInteger
{
#if swift(>=4.2)
% for inlinable in ['@inlinable', '@inline(__always)']:
% end = '#else' if inlinable == '@inlinable' else '#endif'
  ${inlinable}
  public static func atomicLoadThenWrappingIncrement(by operand: ${Type}, at pointer: UnsafeMutablePointer<AtomicStorage>, ordering: AtomicUpdateOrdering) -> ${Type}
  {
    return CAtomicsAdd(pointer, AtomicStorage(operand), ordering._rawValue).decode()
  }
% for (sname, pname, label) in rmwOperations:

  ${inlinable}
  public static func atomicLoadThen${sname}(${label} operand: ${Type}, at pointer: UnsafeMutablePointer<AtomicStorage>, ordering: AtomicUpdateOrdering) -> ${Type}
  {
    return CAtomics${pname}(pointer, AtomicStorage(operand), ordering._rawValue).decode()
  }
% end # rmwOperations
${end}
% end # inlinable
}
% end # for
