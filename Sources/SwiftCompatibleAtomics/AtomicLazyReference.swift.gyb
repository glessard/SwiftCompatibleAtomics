//
//  AtomicLazyReference.swift
//
//  Licensed under Apache License v2.0
//

import CAtomicsPrimitives

public struct UnsafeAtomicLazyReference<Instance: AnyObject>
{
  public typealias AtomicStorage = CAtomics.AtomicOptionalRawPointer

#if swift(>=4.2)
% for inlinable in ['@inlinable', '@inline(__always)']:
% usableFromInline = '@usableFromInline' if inlinable == '@inlinable' else '@_versioned'
% end = '#else' if inlinable == '@inlinable' else '#endif'
  ${usableFromInline}
  internal let _ptr: UnsafeMutablePointer<AtomicStorage>

  ${inlinable}
  public init(at pointer: UnsafeMutablePointer<AtomicStorage>)
  {
    self._ptr = pointer
  }

  ${inlinable}
  public static func create() -> UnsafeAtomicLazyReference<Instance>
  {
    let ptr = UnsafeMutablePointer<AtomicStorage>.allocate(capacity: 1)
    ptr.initialize(to: AtomicOptionalRawPointer(nil))
    return UnsafeAtomicLazyReference(at: ptr)
  }

  ${inlinable}
  public func destroy()
  {
    if let unmanaged = CAtomicsLoad(_ptr, .acquire).map(Unmanaged<Instance>.fromOpaque(_:))
    {
      unmanaged.release()
    }
    _ptr.deinitialize(count: 1)
    _ptr.deallocate()
  }

  ${inlinable}
  public func storeIfNil(_ desired: Instance) -> Instance
  {
    let value = Unmanaged.passRetained(desired)
    var existing = UnsafeRawPointer(bitPattern: 0)
    let success = CAtomicsCompareAndExchangeStrong(_ptr, &existing, value.toOpaque(), .acqrel, .acquire)
    if !success
    {
      value.release()
      return Unmanaged.fromOpaque(existing!).takeUnretainedValue()
    }
    return desired
  }

  ${inlinable}
  public func load() -> Instance?
  {
    if let unmanaged = CAtomicsLoad(_ptr, .acquire).map(Unmanaged<Instance>.fromOpaque(_:))
    {
      return unmanaged.takeUnretainedValue()
    }
    return nil
  }
${end}
% end # for
}
